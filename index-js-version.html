<!DOCTYPE html>
<html>
  <head>
    <title>2048 Game</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: Arial, sans-serif;
        background-color: #faf8ef;
      }

      #grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        background-color: #bbada0;
        padding: 10px;
        border-radius: 5px;
        position: relative;
        width: 380px;
      }

      .grid-cell {
        width: 80px;
        height: 80px;
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 3px;
      }

      .tile {
        position: absolute;
        width: 80px;
        height: 80px;
        background-color: rgba(238, 228, 218, 0.35);
        border-radius: 3px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        transition: all 0.2s ease-in-out;
      }

      .tile.new-tile {
        animation: appear 0.2s ease-in-out;
      }

      .tile.merged {
        animation: pop 0.2s ease-in-out;
      }

      @keyframes appear {
        from {
          opacity: 0;
          transform: scale(0.5);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes pop {
        from {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        to {
          transform: scale(1);
        }
      }

      .tile-2 {
        background-color: #eee4da;
        color: #776e65;
      }

      .tile-4 {
        background-color: #ede0c8;
        color: #776e65;
      }

      .tile-8 {
        background-color: #f2b179;
        color: #f9f6f2;
      }

      .tile-16 {
        background-color: #f59563;
        color: #f9f6f2;
      }

      .tile-32 {
        background-color: #f67c5f;
        color: #f9f6f2;
      }

      .tile-64 {
        background-color: #f65e3b;
        color: #f9f6f2;
      }

      .tile-128 {
        background-color: #edcf72;
        color: #f9f6f2;
        font-size: 20px;
      }

      .tile-256 {
        background-color: #edcc61;
        color: #f9f6f2;
        font-size: 20px;
      }

      .tile-512 {
        background-color: #edc850;
        color: #f9f6f2;
        font-size: 20px;
      }

      .tile-1024 {
        background-color: #edc53f;
        color: #f9f6f2;
        font-size: 18px;
      }

      .tile-2048 {
        background-color: #edc22e;
        color: #f9f6f2;
        font-size: 18px;
      }

      #score {
        margin: 20px 0;
        font-size: 24px;
      }

      /* Add a container for tiles that sits above the grid */
      #tiles-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="score">Score: 0</div>
    <div id="grid">
      <div id="tiles-container"></div>
    </div>

    <script>
      let grid = [];
      let score = 0;
      let waitingForAnimation = false; /* Prevent rapid moves */

      function initializeGrid() {
        grid = Array(4)
          .fill()
          .map(() => Array(4).fill(0));
      }

      function addNewTile() {
        const emptyCells = [];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if (grid[i][j] === 0) {
              emptyCells.push({ x: i, y: j });
            }
          }
        }

        if (emptyCells.length > 0) {
          const { x, y } =
            emptyCells[Math.floor(Math.random() * emptyCells.length)];
          grid[x][y] = Math.random() < 0.9 ? 2 : 4;
        }
      }

      function updateDisplay() {
        const gridContainer = document.getElementById("grid");
        const tilesContainer = document.getElementById("tiles-container");
        tilesContainer.innerHTML = ""; /* Clear existing tiles */

        // Create background grid cells before tiles-container
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            const cell = document.createElement("div");
            cell.className = "grid-cell";
            gridContainer.appendChild(cell);
          }
        }

        // Create and position tiles
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            const value = grid[i][j];
            if (value !== 0) {
              const tile = document.createElement("div");
              tile.className = `tile tile-${value}`;
              tile.textContent = value;
              const x = j * (80 + 10) + 10;
              const y = i * (80 + 10) + 10;
              tile.style.left = x + "px";
              tile.style.top = y + "px";
              tilesContainer.appendChild(tile);
            }
          }
        }

        document.getElementById("score").textContent = `Score: ${score}`;
      }

      function processRow(row) {
        // First, remove zeros and get only the numbers
        let newRow = row.filter((cell) => cell !== 0);
        let merged = Array(newRow.length).fill(false); // Track merged tiles

        // Merge tiles
        for (let i = 0; i < newRow.length - 1; i++) {
          if (!merged[i] && newRow[i] === newRow[i + 1]) {
            newRow[i] *= 2;
            score += newRow[i];
            newRow.splice(i + 1, 1);
            merged[i] = true;

            // Apply merged animation
            const gridContainer = document.getElementById("grid");
            const tileElements = gridContainer.getElementsByClassName(
              `tile-${newRow[i]}`
            );
            for (let tile of tileElements) {
              tile.classList.add("merged");
            }
          }
        }

        // Add zeros back to maintain grid size
        while (newRow.length < 4) {
          newRow.push(0);
        }

        return newRow;
      }

      function move(direction) {
        if (waitingForAnimation) return; /* Prevent multiple moves */
        waitingForAnimation = true;

        const originalGrid = JSON.stringify(grid);

        switch (direction) {
          case "left":
            grid = grid.map((row) => processRow(row));
            break;
          case "right":
            grid = grid.map((row) => processRow([...row].reverse()).reverse());
            break;
          case "up":
            grid = transpose(grid);
            grid = grid.map((row) => processRow(row));
            grid = transpose(grid);
            break;
          case "down":
            grid = transpose(grid);
            grid = grid.map((row) => processRow([...row].reverse()).reverse());
            grid = transpose(grid);
            break;
        }

        if (JSON.stringify(grid) !== originalGrid) {
          setTimeout(() => {
            addNewTile();
            updateDisplay();
            checkGameOver();
            waitingForAnimation = false;
          }, 200); /* Match CSS transition duration */
        } else {
          waitingForAnimation = false;
        }
      }

      function transpose(matrix) {
        return matrix[0].map((_, colIndex) =>
          matrix.map((row) => row[colIndex])
        );
      }

      function checkGameOver() {
        // Check for empty cells
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            if (grid[i][j] === 0) return false;
          }
        }

        // Check for possible merges
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            const current = grid[i][j];
            if (
              (j < 3 && current === grid[i][j + 1]) ||
              (i < 3 && current === grid[i + 1][j])
            ) {
              return false;
            }
          }
        }

        // If no moves left
        alert("Game Over! Score: " + score);
        return true;
      }

      // Initialize game
      document.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowLeft":
            move("left");
            break;
          case "ArrowRight":
            move("right");
            break;
          case "ArrowUp":
            move("up");
            break;
          case "ArrowDown":
            move("down");
            break;
        }
      });

      // Initial setup
      initializeGrid();
      addNewTile();
      addNewTile();
      updateDisplay();
    </script>
  </body>
</html>
